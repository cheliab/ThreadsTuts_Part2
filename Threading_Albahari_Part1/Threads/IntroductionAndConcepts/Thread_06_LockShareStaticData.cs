using System;
using System.Threading;

namespace Threading_Albahari_Part1
{
    /// <summary>
    /// Использование эксклюзивной блокировки для чтения и записи общего поля
    ///
    /// В C# есть оператор lock для этой цели
    /// </summary>
    public class Thread_06_LockShareStaticData
    {
        private static bool _done = false;

        private static readonly object locker = new object();

        public static void Start()
        {
            // Когда два потока одновременно борются за блокировку (в данном случае locker),
            // один поток ожидает или блокируется, пока блокировка не станет доступной.
            // В этом случае это гарантирует, что только один поток может войти в критическую часть кода за раз,
            // а «Done» будет напечатано только один раз.
            //
            // Код, защищенный таким образом - от неопределенности в контексте многопоточности - называется потокобезопасным.
            
            new Thread(Go).Start();
            
            Go();
        }

        private static void Go()
        {
            lock (locker) // эксклюзивная блокировка
            {
                if (!_done) // условие выполнится только 1 раз (второй поток будет заблокирован пока 1 не отпустит locker)
                {
                    Console.WriteLine("Done");
                    _done = true;
                }
            }
        }
        
        // Совместно используемые данные - основная причина сложности и непонятных ошибок в многопоточности.
        // Хотя это часто бывает необходимо, стоит сделать его как можно более простым.
        
        // Блокированный поток не потребляет ресурсы ЦП.
    }
}