using System.Collections.Generic;
using System.Threading;

namespace Threading_Albahari_Part2
{
    /// <summary>
    /// Безопасность потоков на серверах приложений
    ///
    /// Серверы приложений должны быть многопоточными для обработки одновременных клиентских запросов.
    /// Приложения WCF, ASP.NET и веб-служб являются неявно многопоточными;
    /// то же самое верно и для серверных приложений удаленного взаимодействия, которые используют сетевой канал, такой как TCP или HTTP.
    /// Это означает, что при написании кода на стороне сервера вы должны учитывать безопасность потоков,
    /// если есть какая-либо возможность взаимодействия между потоками, обрабатывающими клиентские запросы.
    /// К счастью, такая возможность редка;
    /// типичный серверный класс либо не имеет состояния (без полей),
    /// либо имеет модель активации, которая создает отдельный экземпляр объекта для каждого клиента или каждого запроса.
    /// Взаимодействие обычно возникает только через статические поля, иногда используемые для кэширования в частях памяти базы данных для повышения производительности.
    /// </summary>
    public class ThreadSafety_02_ApplicationServers
    {
        public static void Start()
        {
            new Thread(() =>
            {
                var user1 = UserCache.GetUser(1);
            }).Start();
            
            new Thread(() =>
            {
                var user2 = UserCache.GetUser(1);
            }).Start();
        }
    }

    class User
    {
        public int Id { get; set; }
    }

    class Database
    {
        private static readonly User[] Users = { new() { Id = 1 }, new() { Id = 2 } };
        
        /// <summary>
        /// Получить юзера из БД
        /// </summary>
        /// <param name="id">Идентификатор пользователя</param>
        /// <returns>Пользователь</returns>
        public static User RetriveUser(int id)
        {
            return (User)Users.GetValue(id);
        }
    }

    /// <summary>
    /// Пример потокобезопасного кэша пользователей
    /// </summary>
    static class UserCache
    {
        private static Dictionary<int, User> _users = new Dictionary<int, User>();
        
        /// <summary>
        /// Например, предположим, что у вас есть RetrieveUser метод, который запрашивает базу данных.
        ///
        /// Если этот метод вызывается часто, вы можете повысить производительность, кэшируя результаты в статическом Dictionary.
        /// Вот решение, которое учитывает безопасность потоков:
        /// </summary>
        public static User GetUser(int id)
        {
            User user = null;

            // Блокируем и получаем пользователя из кэша
            lock(_users)
                if (_users.TryGetValue(id, out user))
                    return user;

            user = Database.RetriveUser(id); // Получаем пользователя из БД
            lock (_users) // блокируем кэш и сохраняем пользователя
                _users[id] = user; 
            
            return user;
        }
        
        // Мы должны как минимум заблокировать чтение и обновление словаря, чтобы обеспечить безопасность потоков.
        // В этом примере мы выбираем практический компромисс между простотой и производительностью блокировки.
        // Наш дизайн на самом деле создает очень небольшой потенциал для неэффективности:
        // два потока одновременно вызывают этот метод с одним и тем же ранее не извлеченным id,
        // RetrieveUserметод будет вызываться дважды - и словарь будет обновляться без необходимости.
        // Однократная блокировка для всего метода предотвратит это, но создаст худшую неэффективность:
        // весь кеш будет заблокирован на время вызова RetrieveUser, в течение которого другие потоки будут заблокированы при получении любого пользователя.
    }
}